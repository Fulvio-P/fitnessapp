IMMAGINE DOCKER
    pagina web:
        https://registry.hub.docker.com/_/rabbitmq/?tab=description

    comando base:
        $ docker run -d --hostname <node-name> --name <container-name> rabbitmq:3

        A quanto pare il node name è importante per tenre traccia dei dati.

    Di default, il container si mette in ascolto sulla porta 5672.
    
    C'è anche l'immagine rabbitmq:management che offre un tool di monitorazione
    e controllo, ma non so se ci serve.

USO
    Niente paura: anche se i tutorial di rabbit usano le callback per qualche misterioso
    motivo, la libreria che usano ha anche l'opzione di usare le Promise.

    Sono abbastanza sicuro che ci servirà lo schema RPC: la GUI (o comunque il client)
    chiede al server di fare il sync, il server lo fa e risponde con un messaggio quando
    ha fatto. Nel frattempo, il client vive normalmente.

    Passi lato server (node dovrà mettere su uno o più processi appositi):
        1.  Connessione (<lib>.connect)
        2.  Creazione canale (<conn>.createChannel)
        3.  Creazione coda delle richieste RPC (<chann>.assertQueue)
                Basta una sola coda indipendentemente dal numero di worker.
                Questa coda deve avere un nome ben determinato e noto a tutti i client e server.
                Il tutorial mette durable:false, indicando che non gli interessa
                che le richieste sopravvivano a un riavvio/crash del server.
        4.  <chann>.prefetch(1)
                Vitaletti diceva che questo permette un load balancing più fair
                in caso girino più worker.
        5.  Ascolto sulla coda (<chann>.consume)
                Bisogna definire una funzione handler dei messaggi ricevuti.
                Usare <msg>.content.toString per recuperare i dati contenuti nel messaggio
                    (per noi è irrilevante)
                Usare <msg>.properties per recuperare due parametri interessanti lasciati dal client:
                    replyTo: il nome della coda dove inviare la risposta
                    correlationId: copiare questa proprietà tale e quale come proprietà del
                        messaggio di risposta (3° argomento di sendToQueue)
                Una volta elaborato il messaggio, usare <chann>.sendToQueue per inviare la risposta.
                I dati del messaggio devono essere inviati come Buffer
                    (oggetto di Node che rappresenta sequenze di byte).
                    Usare Buffer.from per trasformare una stringa in un Buffer.
                    Sembra sia il caso di usare sempre stringhe, suggerisco di usare
                        toString o JSON per tutto il resto.
                Alla fine, ricordarsi di usare <chann>.ack per inviare un ACK.
        
    Passi lato client (ascolto risposte)
        1.  Connessione
        2.  Creazione canale
        3.  Creazione coda per le proprie risposte (<chann>.assertQueue)
                Passare "" (o altro valore falso) come 1° argomento per farsi
                    generare il nome dal server.
                Usare l'opzione exclusive:true per dare alla coda scope di connessione
                    ed eliminarla alla fine di questa.
        4.  Ascolto sulla coda
                Anche qui bisogna definire un handler, cosa vogliamo farci
                    dipende da noi. Probabilmente mostrare una finestrella da qualche
                    parte dello schermo. Non vedo troppo bisogno di far dipendere il
                    comportamento dal messaggio di risposta, eccetto distinguere tra un esito
                    di successo e uno d'errore e tutt'al più personalizzare un pochino
                    il messaggio mostrato.
    
    Passi lato client (invio richiesta)
        1.  Connessione
        2.  Creazione canale
        3.  Generare un valore casuale, che sarà il nostro correlationId.
                Serve a riconoscere a quale richiesta corrisponde la risposta
                    che ci arriverà dal server.
                Il tutorial lo genera concatenando tre Math.random().toString().
        4.  Inviare un messaggio contenente la nostra richiesta sulla coda delle richieste
            (stesso nome del server). (<chann>.sendToQueue)
                Apparentemente possiamo usare quella coda direttamente per nome,
                    senza assertarla.
                Nel 3° argomento vanno specificate due proprietà:
                    replyTo: il nome della coda exclusive che abbiamo creato
                        nel flusso "ascolto risposte", per indicare al server
                        su quale coda ci aspettiamo la risposta
                    correlationId: quello generato precedentemente
    
    Lato client: workflow possibili
        Visto che volendo potremmo considerare quello che vogliamo fare come qualcosa
        di meno complesso rispetto a una vera RPC, vedo due possibili modi di
        gestire il lato client:
            1.  Precisamente come il tutorial di rabbit.
                Per qualche coincidenza, consiste nello svolgere i passi delle due
                sezioni precedenti in ordine alterno:
                 - risposte 3
                 - richiesta 3
                 - risposte 4
                 - richieste 4
                Questo è l'approccio più completo.
                Ha anche il vantaggio di rendere le variabili importanti
                (nome della coda esclusiva e correlationID) ben disponibili
                per tutto il tempo che ci interessa.
            2.  Ben separato.
                Al caricamento della pagina, facciamo l'ascolto risposte
                che rimane attivo praticamente all'infinito
                Ogni volta che vogliamo chiamare la nostra procedura,
                facciamo l'invio richiesta.
                Questo è un approccio un po' più semplificato,
                richiede di scriversi il nome della coda da qualche parte
                e ignora il correlationId dato che per questo uso specifico
                potrebbe importarcene poco
            3.  Un approccio più sensato.
                Mi è venuto in mente proprio scrivendo gli altri.
                Apriamo una sola connessione e un solo canale,
                e ce li scriviamo da qualche parte.
                Contestualmente a ciò creiamo la queue exclusive una volta sola,
                e ce la salviamo da qualche parte.
                POI, ogni volta che vogliamo fare una richiesta,
                generiamo il correlationId, ci mettiamo in ascolto sulla
                coda exclusive e inviamo una richiesta al server.
        Problema di un po' tutti questi workflow (tranne forse l'1):
            Come la chiudiamo la connessione?
            C'è un evento che avviene alla chiusura del browser?

        Dato che ci aspettiamo che questa chiamata avvenga AL PIÙ una volta
        per apertura del browser, è meglio usare l'opzione 1 e
        aprire e chiudere connessione, canale e coda ogni volta.
        Non vale la pena di tenere aperto tutto quanto per una cosa
        che si fa (al più) una volta sola.
    
    Memento
        I dati da inviare devono essere convertiti in stringhe prima di essere
            convertiti in Buffer.
        I dati ricevuti devono essere convertiti in stringhe prima di
            ogni ulteriore elaborazione.